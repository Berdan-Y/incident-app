@inject IJSRuntime JS

<MudPaper Class="pa-4" Style="max-width: 450px; margin:auto;">
    <MudTabs>
        <MudTabPanel Text="Camera">
            <MudButton Color="Color.Secondary"
                      Variant="Variant.Outlined"
                      StartIcon="@Icons.Material.Filled.CameraAlt"
                      OnClick="StartCamera"
                      Disabled="isCameraRunning"
                      Class="mb-2">
                Start Camera
            </MudButton>

            <MudButton Color="Color.Primary"
                      Variant="Variant.Filled"
                      StartIcon="@Icons.Material.Filled.PhotoCamera"
                      OnClick="TakePhoto"
                      Disabled="!isCameraRunning"
                      Class="mb-2 ml-2">
                Take Photo
            </MudButton>

            <div>
                <video id="video" autoplay playsinline width="400" style="border-radius:8px; background:#000"></video>
            </div>
        </MudTabPanel>
        
        <MudTabPanel Text="Upload">
            <MudButton Variant="Variant.Filled"
                       Color="Color.Secondary"
                       StartIcon="@Icons.Material.Filled.CloudUpload"
                       OnClick="TriggerFileInput">
                Select Photos
            </MudButton>

            <InputFile id="file-upload" OnChange="OnFilesChanged" multiple style="display:none;" />

            <MudText Typo="Typo.body2" Class="mt-2">
                Supported formats: JPG, JPEG, PNG
            </MudText>
            <MudText Typo="Typo.body2" Class="mt-1">
                Maximum file size: 5MB
            </MudText>
        </MudTabPanel>
    </MudTabs>

    <div class="mt-4">
        @if (capturedImages != null && capturedImages.Count > 0)
        {
            <MudText Typo="Typo.subtitle1">Captured Photo(s):</MudText>
            <MudGrid>
                @foreach (var (img, index) in capturedImages.Select((img, i) => (img, i)))
                {
                    <MudItem xs="12" sm="6" md="4">
                        <MudCard>
                            <MudImage Src="@img" Alt="Captured" ObjectFit="ObjectFit.Cover" Height="200"/>
                            <MudCardActions>
                                <MudButton OnClick="@(() => RemovePhoto(index))" Color="Color.Error" Size="Size.Small">Remove</MudButton>
                            </MudCardActions>
                        </MudCard>
                    </MudItem>
                }
            </MudGrid>
            <MudButton Color="Color.Error"
                      Variant="Variant.Text"
                      StartIcon="@Icons.Material.Filled.Delete"
                      OnClick="@ClearPhotos"
                      Disabled="@(!capturedImages.Any())"
                      Class="mb-2">
                Clear All Photos
            </MudButton>
        }
    </div>
</MudPaper>

@code {
    private bool isCameraRunning = false;
    private List<string> capturedImages = new();
    private ElementReference fileInput;

    [Parameter]
    public EventCallback<List<string>> OnImagesCaptured { get; set; }

    private async Task StartCamera()
    {
        await JS.InvokeVoidAsync("startCamera");
        isCameraRunning = true;
        capturedImages.Clear();
        await OnImagesCaptured.InvokeAsync(capturedImages);
    }

    private async Task TriggerFileInput()
    {
        await JS.InvokeVoidAsync("triggerFileInput");
    }

    private async Task OnFilesChanged(InputFileChangeEventArgs e)
    {
        foreach (var file in e.GetMultipleFiles())
        {
            if (!file.ContentType.StartsWith("image/"))
            {
                Console.WriteLine($"Skipped file '{file.Name}' - not an image.");
                continue;
            }

            if (file.Size > 5 * 1024 * 1024)
            {
                Console.WriteLine($"File '{file.Name}' exceeds size limit of 5MB.");
                continue;
            }

            using var stream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());
            var dataUrl = $"data:{file.ContentType};base64,{base64}";
            
            capturedImages.Add(dataUrl);
        }
        
        await JS.InvokeVoidAsync("setCapturedImages", capturedImages);
        await OnImagesCaptured.InvokeAsync(capturedImages);
        StateHasChanged();
    }
    
    private async Task TakePhoto()
    {
        try
        {
            var photoDataUrl = await JS.InvokeAsync<string>("takePhoto");
            if (!string.IsNullOrWhiteSpace(photoDataUrl))
            {
                capturedImages.Add(photoDataUrl);
                await JS.InvokeVoidAsync("setCapturedImages", capturedImages);
                await OnImagesCaptured.InvokeAsync(capturedImages);
                StateHasChanged();
            }
            else
            {
                Console.WriteLine("No photo returned from JS.");
            }
        }
        catch (JSException jsEx)
        {
            Console.WriteLine($"JavaScript error: {jsEx.Message}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Unexpected error: {ex}");
            throw;
        }
    }
    
    private async Task RemovePhoto(int index)
    {
        if (index >= 0 && index < capturedImages.Count)
        {
            capturedImages.RemoveAt(index);
            await JS.InvokeVoidAsync("setCapturedImages", capturedImages);
            await OnImagesCaptured.InvokeAsync(capturedImages);
            StateHasChanged();
        }
    }
    
    private async Task ClearPhotos()
    {
        capturedImages.Clear();
        await JS.InvokeVoidAsync("setCapturedImages", capturedImages);
        await OnImagesCaptured.InvokeAsync(capturedImages);
    }
}